// Copyright (c) 2023 vesoft inc. All rights reserved.

#pragma once

#include <cassert>
#include <ostream>
#include <string>

#include "nebula/common/base/Logging.h"
#include "nebula/common/base/Status.h"
#include "nebula/common/datatype/Value.h"
#include "nebula/common/utils/Types.h"

namespace nebula {

class Edge;
namespace gql {
class RequestContext;
}

enum class EdgeDirection {
    PointingLeft = 0,
    PointingRight = 1,
    Undirected = 2,
    LeftOrUndirected = 3,
    UndirectedOrRight = 4,
    LeftOrRight = 5,
    AnyDirection = 6,
};

static inline std::string enum2String(EdgeDirection edgeDirection) {
    switch (edgeDirection) {
        case EdgeDirection::PointingLeft:
            return "PointingLeft";
        case EdgeDirection::PointingRight:
            return "PointingRight";
        case EdgeDirection::Undirected:
            return "Undirected";
        case EdgeDirection::LeftOrUndirected:
            return "LeftOrUndirected";
        case EdgeDirection::UndirectedOrRight:
            return "UndirectedOrRight";
        case EdgeDirection::LeftOrRight:
            return "LeftOrRight";
        case EdgeDirection::AnyDirection:
            return "AnyDirection";
    }
    return "INVALID EDGE DIRECTION";
}

static inline std::ostream& operator<<(std::ostream& os, EdgeDirection edgeDirection) {
    os << enum2String(edgeDirection);
    return os;
}

inline std::string edge_prefix(EdgeDirection edgeDirection) {
    switch (edgeDirection) {
        case EdgeDirection::PointingLeft:
            return "<-";
        case EdgeDirection::Undirected:
            return "~";
        case EdgeDirection::PointingRight:
            return "-";
        case EdgeDirection::LeftOrUndirected:
            return "<~";
        case EdgeDirection::UndirectedOrRight:
            return "~";
        case EdgeDirection::LeftOrRight:
            return "<-";
        case EdgeDirection::AnyDirection:
            return "-";
    }
    return "INVALID EDGE DIRECTION";
}
inline std::string edge_postfix(EdgeDirection edgeDirection) {
    switch (edgeDirection) {
        case EdgeDirection::PointingLeft:
            return "-";
        case EdgeDirection::Undirected:
            return "~";
        case EdgeDirection::PointingRight:
            return "->";
        case EdgeDirection::LeftOrUndirected:
            return "~";
        case EdgeDirection::UndirectedOrRight:
            return "~>";
        case EdgeDirection::LeftOrRight:
            return "->";
        case EdgeDirection::AnyDirection:
            return "-";
    }
    return "INVALID EDGE DIRECTION";
}

// The highest two bit represent the direction of the edge:
// 00: outgoing
// 01: incoming
// 10: undirected0
// 11: undirected1

// TODO(jie): Do not embed the edge direction id in the edge type id.
// TODO(jie): Think if undirected edge is necessary.
class EdgeUtils final {
    static constexpr auto kEdgeTypeMoveBits = sizeof(EdgeTypeID) * 8 - 2;

public:
    static EdgeTypeID outgoing(EdgeTypeID typeId) {
        // The highest two bits of edge type id that generated by catalog should be `00`.
        assert(isLegalEdgeTypeID(typeId));
        return typeId & ~(0x3 << kEdgeTypeMoveBits);
    }

    static bool isOutgoing(EdgeTypeID typeId) {
        return (typeId & (0x3 << kEdgeTypeMoveBits)) == 0;
    }

    // 01xxxx
    static EdgeTypeID incoming(EdgeTypeID typeId) {
        // The highest two bits of edge type id that generated by catalog should be `00`.
        assert(isLegalEdgeTypeID(typeId));
        return typeId | (0x1 << kEdgeTypeMoveBits);
    }

    static bool isIncoming(EdgeTypeID typeId) {
        return ((typeId & (0x3 << kEdgeTypeMoveBits)) >> kEdgeTypeMoveBits) == 1;
    }

    // 10xxxx
    static EdgeTypeID undirected0(EdgeTypeID typeId) {
        // The highest two bits of edge type id that generated by catalog should be `00`.
        assert(isLegalEdgeTypeID(typeId));
        return typeId | (0x2 << kEdgeTypeMoveBits);
    }

    static bool isUndirected0(EdgeTypeID typeId) {
        return (((typeId & (0x3 << kEdgeTypeMoveBits)) >> kEdgeTypeMoveBits) & 0x3) == 0x2;
    }

    // 11xxxx
    static EdgeTypeID undirected1(EdgeTypeID typeId) {
        // The highest two bits of edge type id that generated by catalog should be `00`.
        assert(isLegalEdgeTypeID(typeId));
        return typeId | (0x3 << kEdgeTypeMoveBits);
    }

    static bool isUndirected1(EdgeTypeID typeId) {
        return (((typeId & (0x3 << kEdgeTypeMoveBits)) >> kEdgeTypeMoveBits) & 0x3) == 0x3;
    }

    static EdgeTypeID reverse(EdgeTypeID typeId) {
        return typeId ^ (0x1 << kEdgeTypeMoveBits);
    }

    // Get the edge type id generated by catalog
    static EdgeTypeID removeDirection(EdgeTypeID typeId) {
        return typeId & ~(0x3 << kEdgeTypeMoveBits);
    }

    // Tests whether the two edge type id are belong to the same edge type
    static bool isSameEdgeType(EdgeTypeID typeId1, EdgeTypeID typeId2) {
        return removeDirection(typeId1) == removeDirection(typeId2);
    }

    // Tests whether the edge type id is directed: outgoing or incoming
    static bool isDirected(EdgeTypeID typeId) {
        return (typeId & (0x2 << kEdgeTypeMoveBits)) == 0;
    }

    static bool isOutgoingOrUndirected0(EdgeTypeID typeId) {
        return (typeId >> kEdgeTypeMoveBits & 0x1) == 0;
    }

    static std::vector<EdgeTypeID> allEdgeTypesFor(EdgeDirection direction,
                                                   EdgeTypeID edgeTypeId) {
        std::vector<EdgeTypeID> edgeTypeIds;
        switch (direction) {
            case EdgeDirection::PointingLeft:
                edgeTypeIds.emplace_back(incoming(edgeTypeId));
                break;
            case EdgeDirection::PointingRight:
                edgeTypeIds.emplace_back(outgoing(edgeTypeId));
                break;
            case EdgeDirection::Undirected:
                edgeTypeIds.emplace_back(undirected0(edgeTypeId));
                edgeTypeIds.emplace_back(undirected1(edgeTypeId));
                break;
            case EdgeDirection::LeftOrUndirected:
                edgeTypeIds.emplace_back(incoming(edgeTypeId));
                edgeTypeIds.emplace_back(undirected0(edgeTypeId));
                edgeTypeIds.emplace_back(undirected1(edgeTypeId));
                break;
            case EdgeDirection::UndirectedOrRight:
                edgeTypeIds.emplace_back(undirected0(edgeTypeId));
                edgeTypeIds.emplace_back(undirected1(edgeTypeId));
                edgeTypeIds.emplace_back(outgoing(edgeTypeId));
                break;
            case EdgeDirection::LeftOrRight:
                edgeTypeIds.emplace_back(incoming(edgeTypeId));
                edgeTypeIds.emplace_back(outgoing(edgeTypeId));
                break;
            case EdgeDirection::AnyDirection:
                edgeTypeIds.emplace_back(incoming(edgeTypeId));
                edgeTypeIds.emplace_back(outgoing(edgeTypeId));
                edgeTypeIds.emplace_back(undirected0(edgeTypeId));
                edgeTypeIds.emplace_back(undirected1(edgeTypeId));
                break;
            default:
                LOG(FATAL) << V_STATUS(UNSUPPORTED_EDGE_DIRECTION,
                                       static_cast<int32_t>(direction));
        }
        return edgeTypeIds;
    }

    static StatusOr<EdgeRank> genRank(gql::RequestContext* rctx,
                                      const properties_type& props,
                                      const catalog::EdgeType* edgeType);

private:
    static bool isLegalEdgeTypeID(EdgeTypeID typeId) {
        return (typeId & (0x3 << kEdgeTypeMoveBits)) == 0;
    }
};

}  // namespace nebula
